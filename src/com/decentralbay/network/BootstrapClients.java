package com.decentralbay.network;



import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.logging.ConsoleHandler;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

/**
 * A quick and dirty example of query DNS A record and log response.
 * This code has no error handling.
 *
 */

public class BootstrapClients {
	private static final String filePath = "decentralbay.plist";
    private static final String DNS_SERVER_ADDRESS = "8.8.8.8";
    private static final int DNS_SERVER_PORT = 53;
    private static final boolean onlylocal = true;
    private static final boolean appendips = true;
	private final static Logger logger = Logger.getLogger(BootstrapClients.class.getName());
	
	public static void main(String[] args) {
		try {
			init();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
    public static void init() throws IOException {
    	initLogger();
    	File yourFile = new File(filePath);
    	
    	if(!yourFile.exists()) {
    		yourFile.createNewFile();	
    	}
    	
    	checkCorruptLines();
    	if(!appendips) {
        	emptyFile();
        }
    	DNSBootstrap();
    }
    
    
    private static void DNSBootstrap() throws IOException {
        String domain = "decentral.dns-cloud.net";
        InetAddress ipAddress = InetAddress.getByName(DNS_SERVER_ADDRESS);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);

        // *** Build a DNS Request Frame ****

        // Identifier: A 16-bit identification field generated by the device that creates the DNS query. 
        // It is copied by the server into the response, so it can be used by that device to match that 
        // query to the corresponding reply received from a DNS server. This is used in a manner similar 
        // to how the Identifier field is used in many of the ICMP message types.
        dos.writeShort(0x1234);

        // Write Query Flags
        dos.writeShort(0x0100);

        // Question Count: Specifies the number of questions in the Question section of the message.
        dos.writeShort(0x0001);

        // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
        dos.writeShort(0x0000);

        // Authority Record Count: Specifies the number of resource records in the Authority section of 
        // the message. (“NS” stands for “name server”)
        dos.writeShort(0x0000);

        // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
        dos.writeShort(0x0000);

        String[] domainParts = domain.split("\\.");
        
        for (int i = 0; i<domainParts.length; i++) {
            byte[] domainBytes = domainParts[i].getBytes("UTF-8");
            dos.writeByte(domainBytes.length);
            dos.write(domainBytes);
        }

        // No more parts
        dos.writeByte(0x00);

        // Type 0x01 = A (Host Request)
        dos.writeShort(0x0001);

        // Class 0x01 = IN
        dos.writeShort(0x0001);

        byte[] dnsFrame = baos.toByteArray();


        
        // *** Send DNS Request Frame ***
        DatagramSocket socket = new DatagramSocket();
        DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, DNS_SERVER_PORT);
        socket.send(dnsReqPacket);

        // Await response from DNS server
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);
        socket.receive(packet);

        
        
        DataInputStream din = new DataInputStream(new ByteArrayInputStream(buf));
        
        String transactionId = String.format("%x", din.readShort());
        String flags = String.format("%x", din.readShort());
        String questions = String.format("%x", din.readShort());
        String answers = String.format("%x", din.readShort());
        String authority = String.format("%x", din.readShort());
        String additional = String.format("%x", din.readShort());



        int recLen = 0;
        while ((recLen = din.readByte()) > 0) {
            byte[] record = new byte[recLen];

            for (int i = 0; i < recLen; i++) {
                record[i] = din.readByte();
            }
        }

        String recordType = String.format("%x", din.readShort());
        String classType = String.format("%x", din.readShort());
        String field = String.format("%x", din.readShort());
        String type = String.format("%x", din.readShort());
        String classT = String.format("%x", din.readShort());
        String ttl = String.format("%x", din.readInt());
        
        short addrLen = din.readShort();
       
        byte[] ba1 = new byte[packet.getLength()];
        
        for (int i = 0; i < packet.getLength(); i++ ) {
            ba1[i] = din.readByte();
        }
        
        int emptyBytesCounter = 0;
        boolean keepCounting = true;
        ArrayList<String> temp = new ArrayList<String>();
        
    		
        while(keepCounting == true) {
        	for (int i = 0; i < ba1.length; i++) {		        		
            	if(i >= 1) {
            		if(emptyBytesCounter <= 4) {
                    	if (String.format("%d", (ba1[i] & 0xFF)).equals("0") && String.format("%d", (ba1[i-1] & 0xFF)).equals("0")) {
                    		emptyBytesCounter++;
                    	}
                    	
            		    if(i%4 == 0) {
            		    	temp.add(String.format("%d", (ba1[i] & 0xFF)) + ".");
            		    } else {
            		    	temp.add(String.format("%d", (ba1[i] & 0xFF)) + ".");
            		    }
            		} else {
            			keepCounting = false;
            		}
            	} else {
            		temp.add(String.format("%d", (ba1[i] & 0xFF)) + ".");
            	}
            }
        }   		
    	logger.log(Level.INFO, "IP Bootstrapping from DNS Seed finished!");
    	
    	String tempString = "";
    	ArrayList<String> finalPool = new ArrayList<String>();
    	
    	for (int i = 0; i < temp.size(); i++) {
			if (i != 0) {
				if(i%4 != 0) {
					tempString += temp.get(i);
				} else {
					finalPool.add(tempString.substring(0, tempString.length() - 1));
					tempString = "";
					tempString += temp.get(i);
				}
			} else {
				tempString += temp.get(0);
			}
		}
    	
    	for(String ip: finalPool) {
    		addIp(ip);
    	}
    	socket.close();
    	logger.log(Level.INFO, "File decentralbay.plist refreshed with new Peers!"); 
    }
    
    
    public static void addIp(String ip) {
    	ip = ip.replaceAll("\\/", "");
    	try(FileWriter fw = new FileWriter(filePath, true);
	    BufferedWriter bw = new BufferedWriter(fw);
	    
    	PrintWriter out = new PrintWriter(bw)) {
		    if(onlylocal) {
		    	if(ip.length() >= 9) {
		    		if(ip.substring(0, 9).equals("192.168.1") || ip.substring(0, 8).equals("127.0.0.") || ip.substring(1, ip.length()).equals(InetAddress.getLocalHost().getHostAddress())) {
		    			if(findIp(ip) == false) {	
		    				out.println(ip);		    			
		    			}
		    		}
			    } 
		    } else if (onlylocal == false){
		    	out.println(ip);
		    }
		} catch (IOException e) {
		    //exception handling left as an exercise for the reader
			e.printStackTrace();
		} finally {
			
		}
    }
    
    
    private static void checkCorruptLines() throws IOException {
    	BufferedReader reader = new BufferedReader(new FileReader(filePath));
    	String currentLine;
    	int temp = 0;
    	
		while((currentLine = reader.readLine()) != null) {
		    // trim newline when comparing with lineToRemove
			for (int i = 0; i < currentLine.length(); i++) {
				if(String.valueOf(currentLine.charAt(i)).equals(".")) {
					temp++;
				}
				if(!String.valueOf(currentLine.charAt(i)).equals("0") && !String.valueOf(currentLine.charAt(i)).equals("1") &&
						!String.valueOf(currentLine.charAt(i)).equals("2") && !String.valueOf(currentLine.charAt(i)).equals("3") && 
						!String.valueOf(currentLine.charAt(i)).equals("4") && !String.valueOf(currentLine.charAt(i)).equals("5") &&
						!String.valueOf(currentLine.charAt(i)).equals("6") && !String.valueOf(currentLine.charAt(i)).equals("7") && 
						!String.valueOf(currentLine.charAt(i)).equals("8") && !String.valueOf(currentLine.charAt(i)).equals("9") &&
						!String.valueOf(currentLine.charAt(i)).equals(".")) {
					deleteIp(currentLine);
				}
		    }
			if(temp > 3) {
				deleteIp(currentLine);
			}
			temp = 0;
		}
    	reader.close();
    }
    
    
    private static boolean findIp(String ip) throws IOException {
    	BufferedReader reader = new BufferedReader(new FileReader(filePath));
    	String currentLine;
    	
    	while((currentLine = reader.readLine()) != null) {
    	    // trim newline when comparing with lineToRemove
    	    if(currentLine.equals(ip)) {
    	    	reader.close();
    	    	return true;
    	    }
    	}
    	reader.close();
    	return false;
    }
    
    
    public static void deleteIp(String ip) throws IOException {
    	BufferedReader reader = new BufferedReader(new FileReader(filePath));
    	BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
    	String currentLine = null;
    	
    	while((currentLine = reader.readLine()) != null) {
    	    // trim newline when comparing with lineToRemove
    	    if(currentLine.equals(ip)) {
    	    	writer.write(String.valueOf(null));
    	    	reader.close();
    	    	writer.close();
    	    }
    	}
    }
    
    
    private static void emptyFile() throws FileNotFoundException {
    	PrintWriter writer = new PrintWriter(filePath);
    	writer.print("");
    	writer.close();
    }
    
    
    private static void initLogger() {
		LogManager.getLogManager().reset();
		logger.setLevel(Level.ALL);
		ConsoleHandler ch = new ConsoleHandler();
		ch.setLevel(Level.FINE);
		logger.addHandler(ch);
		
		
		
		try {
			FileHandler fileHandler = new FileHandler("NetworkLogger.log");
			fileHandler.setLevel(Level.FINE);			
			logger.addHandler(fileHandler);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "File logger not working!", e);
		}
    }
}